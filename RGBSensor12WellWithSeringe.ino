#include <SPI.h>
#include <Arduino.h>
#include "LTC2484.h"
#include "LTC24XX_general.h"
#include <SoftwareSerial.h>
#include <SparkFunBLEMate2.h>
#define REPEATS 1
#define LENGTH 25
#define ELENO 8
#define TIME_LIMIT 120000

#define Enable A0
#define in1 A1
#define in2 A2
#define Limit1 A3
#define Limit2 A4
#define PWM 160

#define MUX1 28
#define MUX2 29
#define MUX3 30
#define CH0  27
#define CH1  26
#define CH2  24
#define CH3  25
#define CSR  7
#define CSG  6
#define CSB  5


int32_t rawadcvalue, rawadcvaluepart1;
int32_t purgevalue;
uint32_t processedadcvalue;

char message[LENGTH];

int bluetoothTx = A11;
int bluetoothRx = A12;
int testrunning;
SoftwareSerial bluetoothSerial(bluetoothTx, bluetoothRx);
BLEMate2 BTModu(&bluetoothSerial);

void setup() {
  // We initialize serial communication, setup the SPI pins and lighting/power pins as outputs, and initialize the lights to OFF
  Serial.begin(9600);
  bluetoothSerial.begin(9600);
  
  //Pins that go to the light detector
  pinMode(CSR, OUTPUT);
  pinMode(CSG, OUTPUT);
  pinMode(CSB, OUTPUT);

  pinMode(CH0, OUTPUT);
  pinMode(CH1, OUTPUT);
  pinMode(CH2, OUTPUT);
  pinMode(CH3, OUTPUT);
  pinMode(MUX1, OUTPUT);
  pinMode(MUX2, OUTPUT);
  pinMode(MUX3, OUTPUT);

  // Pins that go to the pump?
  pinMode(34, OUTPUT);
  pinMode(35, OUTPUT);
  pinMode(36, OUTPUT);
  pinMode(37, OUTPUT);
  pinMode(38, OUTPUT);
  pinMode(39, OUTPUT);
  pinMode(40, OUTPUT);
  pinMode(41, OUTPUT);
  pinMode(42, OUTPUT);
  pinMode(43, OUTPUT);
  pinMode(44, OUTPUT);
  pinMode(45, OUTPUT);
  pinMode(46, OUTPUT);

  SPI.setDataMode(SPI_MODE0);
  SPI.setClockDivider(SPI_CLOCK_DIV128);
  SPI.setBitOrder(MSBFIRST);

  digitalWrite(CSR, HIGH);
  digitalWrite(CSG, HIGH);
  digitalWrite(CSB, HIGH);

  digitalWrite(CH0, HIGH);
  digitalWrite(CH1, HIGH);
  digitalWrite(CH2, LOW);
  digitalWrite(CH3, HIGH);

  digitalWrite(MUX1, HIGH);
  digitalWrite(MUX2, HIGH);
  digitalWrite(MUX3, HIGH);

  digitalWrite(34, LOW);
  digitalWrite(35, LOW);
  digitalWrite(36, LOW);
  digitalWrite(37, LOW);
  digitalWrite(38, LOW);
  digitalWrite(39, LOW);
  digitalWrite(40, LOW);
  digitalWrite(41, LOW);
  digitalWrite(42, LOW);
  digitalWrite(43, LOW);
  digitalWrite(44, LOW);
  digitalWrite(45, LOW);
  digitalWrite(46, LOW);

  testrunning = 0;

  pinMode(Enable, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(Limit1, INPUT);
  pinMode(Limit2, INPUT);

  while(digitalRead(Limit1) == HIGH && millis()<=10000) { 
    digitalWrite(in1, HIGH);
    analogWrite(Enable, PWM);
    Serial.println("setting");
  }
  digitalWrite(in1, LOW);
  Serial.println("set");

  setupBluetooth();
}


void loop() {
    
}


void setupBluetooth()
{
  // Regarding function return values: most functions that interact with the
  //  BC118 will return BLEMate2::opResult values. The possible values here
  //  are:
  //  REMOTE_ERROR - No remote devices exist.
  //  INVALID_PARAM - You've called the function with an invalid parameter.
  //  TIMEOUT_ERROR - The BC118 failed to respond to the command in a timely
  //                   manner; timely is redefined for each command.
  //  MODULE_ERROR - The BC118 didn't like the command string it received.
  //                  This will probably only occur when you attempt to send
  //                  commands and parameters outside the built-ins. 
  //  SUCCESS - What it says.
  
  // Reset is a blocking function which gives the BC118 a few seconds to reset.
  //  After a reset, the module will return to whatever settings are in
  //  non-volatile memory. One other *super* important thing it does is issue
  //  the "SCN OFF" command after the reset is completed. Why is this important?
  //  Because if the device is in central mode, it *will* be scanning on reset.
  //  No way to change that. The text traffic generated by the scanning will
  //  interfere with the firmware on the Arduino properly identifying response
  //  strings from the BC118.
  if (BTModu.reset() != BLEMate2::SUCCESS)
  {
    Serial.println("Module reset error!");
    while (1);
  }

  // restore() resets the module to factory defaults; you'll need to perform
  //  a writeConfig() and reset() to make those settings take effect. We don't
  //  do that automatically because there may be things the user wants to
  //  change before committing the settings to non-volatile memory and
  //  resetting.
  if (BTModu.restore() != BLEMate2::SUCCESS)
  {
    Serial.println("Module restore error!");
    while (1);
  }
  // writeConfig() stores the current settings in non-volatile memory, so they
  //  will be in place on the next reboot of the module. Note that some, but
  //  not all, settings changes require a reboot. It's probably in general best
  //  to write/reset when changing anything.
  if (BTModu.writeConfig() != BLEMate2::SUCCESS)
  {
    Serial.println("Module write config error!");
    while (1);
  }
  // One more reset, to make the changes take effect.
  if (BTModu.reset() != BLEMate2::SUCCESS)
  {
    Serial.println("Second module reset error!");
    while (1);
  }

  // The default settings are good enough for the peripheral example; just to
  //  be on the safe side, we'll check the amICentral() function and do a r/w/r
  //  if we're in central mode instead of peripheral mode.

  boolean inCentralMode = false;
  // A word here on amCentral: amCentral's parameter is passed by reference, so
  //  the answer to the question "am I in central mode" is handed back as the
  //  value in the boolean passed to it when it is called. The reason for this
  //  is the allow the user to check the return value and determine if a module
  //  error occurred: should I trust the answer or is there something larger
  //  wrong than merely being in the wrong mode?
  BTModu.amCentral(inCentralMode); 
  if (inCentralMode)
  {
    BTModu.BLEPeripheral();
    BTModu.BLEAdvertise();
  }

  // There are a few more advance settings we'll probably, but not definitely,
  //  want to tweak before we reset the device.

  // The CCON parameter will enable advertising immediately after a disconnect.
  BTModu.stdSetParam("CCON", "ON");
  // The ADVP parameter controls the advertising rate. Can be FAST or SLOW.
  BTModu.stdSetParam("ADVP", "FAST");
  // The ADVT parameter controls the timeout before advertising stops. Can be
  //  0 (for never) to 4260 (71min); integer value, in seconds.
  BTModu.stdSetParam("ADVT", "0");
  // The ADDR parameter controls the devices we'll allow to connect to us.
  //  All zeroes is "anyone".
  BTModu.stdSetParam("ADDR", "000000000000");

  BTModu.writeConfig();
  BTModu.reset();
  
  // We're set up to allow anything to connect to us now.
}

void RETRACT() {//syringe makes a vacuum 
  while(digitalRead(Limit2) == HIGH){
  digitalWrite(in2, HIGH);
  analogWrite(Enable, PWM);
  Serial.println("Retracting");
  }
  digitalWrite(in2, LOW);
  Serial.println("Retracted");
}

void RETURN() {//returns to original position
   while(digitalRead(Limit1)== HIGH){
  digitalWrite(in1, HIGH);
  analogWrite(Enable, PWM);
    Serial.println("Returning");
   }
  digitalWrite(in1, LOW);
Serial.println("Returned");
}

