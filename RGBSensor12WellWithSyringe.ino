#include "Sensor.h"
#include "Settings.h"

int bluetoothTx = A11;
int bluetoothRx = A12;
bool runSensors;
SoftwareSerial bluetoothSerial(bluetoothTx, bluetoothRx);
BLEMate2 BTModu(&bluetoothSerial);

Sensor sensors[12];

static String fullBuffer = "";
static long lastRXTime = millis();
static String inputBuffer;

void setup() {
  // We initialize serial communication, setup the SPI pins and lighting/power pins as outputs, and initialize the lights to OFF
  Serial.begin(9600);
  bluetoothSerial.begin(9600);
  
  // Process to setup the pins that go to the light detector
  Serial.println("Setup Detector pins...");
  setupLightDetectorPins();

  // Process to setup the pins that control the lights
  Serial.println("Setup Light pins...");
  setupLightPins();

  // Process to setup the pump
  Serial.println("Setup Pump...");
  setupPump();

  // Process to setup bluetooth
  Serial.println("Setup Bluetooth...");
  setupBluetooth();
  
  // initialize the SPI
  Serial.println("Initialize SPI...");
  SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE0));

  // Process to setup the sensors
  Serial.println("Setup sensors...");
  setupSensors();

  runSensors = false;
}

void loop() {
  // Since I'm going to be reporting strings back over serial to the PC, I want
  //  to make sure that I'm (probably) not going to be looking away from the BLE
  //  device during a data receive period. I'll *guess* that, if more than 1000
  //  milliseconds has elapsed since my last receive, that I'm in a quiet zone
  //  and I can switch over to the PC to report what I've heard.
  
  if (lastRXTime + 1000 < millis())
  {
    if (fullBuffer != "")
    {
      Serial.println(fullBuffer);
      fullBuffer = "";
    }
  }
  processReceivedData2();
  
  if (runSensors) { // Should eventually become while loop with a check to see if runSensors becomes false
    Serial.println("Running Sensors");
    for(Sensor& sensor : sensors) {
      sensor.readRGB(BTModu);
    }
  }
  // processReceivedData();
}

void setupLightDetectorPins() {
  pinMode(CSR, OUTPUT);
  pinMode(CSG, OUTPUT);
  pinMode(CSB, OUTPUT);

  pinMode(CH0, OUTPUT);
  pinMode(CH1, OUTPUT);
  pinMode(CH2, OUTPUT);
  pinMode(CH3, OUTPUT);
  pinMode(MUX1, OUTPUT);
  pinMode(MUX2, OUTPUT);
  pinMode(MUX3, OUTPUT);

  digitalWrite(CSR, HIGH);
  digitalWrite(CSG, HIGH);
  digitalWrite(CSB, HIGH);

  digitalWrite(CH0, HIGH);
  digitalWrite(CH1, HIGH);
  digitalWrite(CH2, LOW);
  digitalWrite(CH3, HIGH);

  digitalWrite(MUX1, HIGH);
  digitalWrite(MUX2, HIGH);
  digitalWrite(MUX3, HIGH);
}

void setupLightPins() {
  pinMode(LED0, OUTPUT);
  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(LED3, OUTPUT);
  pinMode(LED4, OUTPUT);
  pinMode(LED5, OUTPUT);
  pinMode(LED6, OUTPUT);
  pinMode(LED7, OUTPUT);
  pinMode(LED8, OUTPUT);
  pinMode(LED9, OUTPUT);
  pinMode(LED10, OUTPUT);
  pinMode(LED11, OUTPUT);

  digitalWrite(LED0, LOW);
  digitalWrite(LED1, LOW);
  digitalWrite(LED2, LOW);
  digitalWrite(LED3, LOW);
  digitalWrite(LED4, LOW);
  digitalWrite(LED5, LOW);
  digitalWrite(LED6, LOW);
  digitalWrite(LED7, LOW);
  digitalWrite(LED8, LOW);
  digitalWrite(LED9, LOW);
  digitalWrite(LED10, LOW);
  digitalWrite(LED11, LOW);
}

void setupPump() {
  pinMode(Enable, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(Limit1, INPUT);
  pinMode(Limit2, INPUT);

  while (digitalRead(Limit1) == HIGH && millis() <= 10000)
  {
    digitalWrite(in1, HIGH);
    analogWrite(Enable, PWM);
    Serial.println("setting");
  }
  digitalWrite(in1, LOW);
  Serial.println("set");
}

void setupBluetooth() {
  // Regarding function return values: most functions that interact with the
  //  BC118 will return BLEMate2::opResult values. The possible values here
  //  are:
  //  REMOTE_ERROR - No remote devices exist.
  //  INVALID_PARAM - You've called the function with an invalid parameter.
  //  TIMEOUT_ERROR - The BC118 failed to respond to the command in a timely
  //                   manner; timely is redefined for each command.
  //  MODULE_ERROR - The BC118 didn't like the command string it received.
  //                  This will probably only occur when you attempt to send
  //                  commands and parameters outside the built-ins. 
  //  SUCCESS - What it says.
  
  // Reset is a blocking function which gives the BC118 a few seconds to reset.
  //  After a reset, the module will return to whatever settings are in
  //  non-volatile memory. One other *super* important thing it does is issue
  //  the "SCN OFF" command after the reset is completed. Why is this important?
  //  Because if the device is in central mode, it *will* be scanning on reset.
  //  No way to change that. The text traffic generated by the scanning will
  //  interfere with the firmware on the Arduino properly identifying response
  //  strings from the BC118.
  if (BTModu.reset() != BLEMate2::SUCCESS)
  {
    Serial.println("Module reset error!");
    while (1);
  }

  // restore() resets the module to factory defaults; you'll need to perform
  //  a writeConfig() and reset() to make those settings take effect. We don't
  //  do that automatically because there may be things the user wants to
  //  change before committing the settings to non-volatile memory and
  //  resetting.
  if (BTModu.restore() != BLEMate2::SUCCESS)
  {
    Serial.println("Module restore error!");
    while (1);
  }
  // writeConfig() stores the current settings in non-volatile memory, so they
  //  will be in place on the next reboot of the module. Note that some, but
  //  not all, settings changes require a reboot. It's probably in general best
  //  to write/reset when changing anything.
  if (BTModu.writeConfig() != BLEMate2::SUCCESS)
  {
    Serial.println("Module write config error!");
    while (1);
  }
  // One more reset, to make the changes take effect.
  if (BTModu.reset() != BLEMate2::SUCCESS)
  {
    Serial.println("Second module reset error!");
    while (1);
  }

  // The default settings are good enough for the peripheral example; just to
  //  be on the safe side, we'll check the amICentral() function and do a r/w/r
  //  if we're in central mode instead of peripheral mode.

  boolean inCentralMode = false;
  // A word here on amCentral: amCentral's parameter is passed by reference, so
  //  the answer to the question "am I in central mode" is handed back as the
  //  value in the boolean passed to it when it is called. The reason for this
  //  is the allow the user to check the return value and determine if a module
  //  error occurred: should I trust the answer or is there something larger
  //  wrong than merely being in the wrong mode?
  BTModu.amCentral(inCentralMode); 
  if (inCentralMode)
  {
    BTModu.BLEPeripheral();
    BTModu.BLEAdvertise();
  }

  // There are a few more advance settings we'll probably, but not definitely,
  //  want to tweak before we reset the device.

  // The CCON parameter will enable advertising immediately after a disconnect.
  BTModu.stdSetParam("CCON", "ON");
  // The ADVP parameter controls the advertising rate. Can be FAST or SLOW.
  BTModu.stdSetParam("ADVP", "FAST");
  // The ADVT parameter controls the timeout before advertising stops. Can be
  //  0 (for never) to 4260 (71min); integer value, in seconds.
  BTModu.stdSetParam("ADVT", "0");
  // The ADDR parameter controls the devices we'll allow to connect to us.
  //  All zeroes is "anyone".
  BTModu.stdSetParam("ADDR", "000000000000");

  BTModu.writeConfig();
  BTModu.reset();
  
  // We're set up to allow anything to connect to us now.
}

void setupSensors() {
  char names[12] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l'};
  Serial.println("Setting up detector pins: ");
  Serial.print("\t");
  for(int i=0; i<12; i++) {
    sensors[i].setup(names[i], i);
    Serial.print(sensors[i].getName());
  }
  Serial.println();
}

void RETRACT() {// syringe makes a vacuum to pull water
  while(digitalRead(Limit2) == HIGH){
    digitalWrite(in2, HIGH);
    analogWrite(Enable, PWM);
    Serial.println("Retracting");
  }
  digitalWrite(in2, LOW);
  Serial.println("Retracted");
}

void RETURN() {// syringe returns to original position
  while(digitalRead(Limit1)== HIGH){
    digitalWrite(in1, HIGH);
    analogWrite(Enable, PWM);
    Serial.println("Returning");
  }
  digitalWrite(in1, LOW);
  Serial.println("Returned");
}

void processReceivedData() {
  // buffer for RCV data
  static uint8_t fullBufferByte[LENGTH];

  // buffer for bluetooth Data
  static uint8_t inputBuffer[LENGTH];
  
  byte mode = 0;

  //RCV buffer index pointer
  static uint8_t iFullBuffer = 0;

  // bluetooth Serail buffer index pointer
  static uint8_t iInputBuffer = 0;
  
  //I dunno what this does...
  uint8_t electrode;

  static long lastRXTime = millis();
  
  // I dunno what this does either...
  // use union to convert byte array to uint32_t
  union fourByte {
    uint32_t dataFrequency;
    uint8_t dataByte[4];
  };
  union fourByte dataVal;

  // if more than 1000
  // milliseconds has elapsed since last receive
  // parse the command from Iphone apps

  if (lastRXTime + 1000 < millis())
  {
    // if there is data in the RCV buffer
    if (iFullBuffer != 0)
    {
      // first byte is the mode
      Serial.print("byte buffer:");
      Serial.println(fullBufferByte[0], DEC);
      mode = fullBufferByte[0];

      iFullBuffer = 0;
    }
  }

  iInputBuffer = 0;
  // read data from bluetooth
  while (bluetoothSerial.available() > 0)
  {
    inputBuffer[iInputBuffer] = (uint8_t)bluetoothSerial.read();
    iInputBuffer++;
    lastRXTime = millis();
  }

  // check to see if the string
  // and data looks like this:
  // RCV=20 char max msg\n\r

  // if yes copy it to fullBufferByte array

  if (strncmp((char *)&inputBuffer[iInputBuffer - 2], "\n\r", 2) == 0)
  {

    if (strncmp((char *)&inputBuffer[0], "RCV=", 4) == 0)
    {
      Serial.println("This is a RCV");

      // copy to RCV buffer
      uint8_t i;
      i = 4;
      iInputBuffer = iInputBuffer - 2;
      while (i < iInputBuffer)
      {
        fullBufferByte[iFullBuffer] = inputBuffer[i];
        iFullBuffer++;
        i++;
      }
      iInputBuffer = 0;
    }
    else
    {
      iInputBuffer = 0;
    }
  }
  chooseMode(mode);
}

processReceivedData2() {
  // This is the peripheral example code.

    // When a remote module connects to us, we'll start to see a bunch of stuff.
    //  Most of that is just overhead; we don't really care about it. All we
    //  *really* care about is data, and data looks like this:
    // RCV=20 char max msg\n\r

    // The state machine for capturing that can be pretty easy: when we've read
    //  in \n\r, check to see if the string began with "RCV=". If yes, do
    //  something. If no, discard it.
    while (bluetoothSerial.available() > 0)
    {
      inputBuffer.concat((char)bluetoothSerial.read());
      lastRXTime = millis();
    }

    // We'll probably see a lot of lines that end with \n\r- that's the default
    //  line ending for all the connect info messages, for instance. We can
    //  ignore all of them that don't start with "RCV=". Remember to clear your
    //  String object after you find \n\r!!!
    if (inputBuffer.endsWith("\n\r"))
    {
      if (inputBuffer.startsWith("RCV="))
      {
        inputBuffer.trim(); // Remove \n\r from end.
        inputBuffer.remove(0,4); // Remove RCV= from front.
        fullBuffer += inputBuffer;
        inputBuffer = "";
      }
      else
      {
        inputBuffer = "";
      }
    }
}

void chooseMode(byte mode) {
  Serial.print("Mode: ");
  Serial.println(mode);
  switch (mode)
  {
  case 66: // For beginning the stream (ASCII B)
    Serial.println("Begin Running the sensors.");
    runSensors = true;
    mode = 0;
    break;

  case 83: // For stopping the stream (ASCII S)
    Serial.println("Stop Running the sensors.");
    runSensors = false;
    mode = 0;
    break;

  case 77: // For retracting the syringe pump (ASCII M)
    Serial.println("Retract pump.");
    RETRACT();
    break;

  case 79: // For returning the syringe pump (ASCII O)
    Serial.println("Return pump.");
    RETURN();
    break;

  default:
    break;
  }
  //delay(100);
}
